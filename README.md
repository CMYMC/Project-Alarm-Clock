#  Alarm Clock

## 0. 시연영상
https://github.com/user-attachments/assets/d13fb34c-4177-40e8-9ee9-fa02c0ec79d5

## 1. 개요

**STM32 MCU의 내부 자원(Flash, Timer, ADC)을 최대로 활용한 디지털 알람 시계입니다. 단순한 시간 표시를 넘어, 상태 머신을 통한 체계적인 모드 관리와 Flash 메모리 제어를 통해 데이터 보존성을 구현
STM32F429ZI Nucleo** 보드를 기반으로 제작한  알람 시계입니다. 일상생활에서 실제로 활용 가능한 시계를 목표로 개발하였으며, 기본적인 시간 및 알람 설정 기능 외에도 사용자가 원하는 알람 음악을 선택 및 제어할 수 있는 기능을 구현했습니다.
본 프로젝트는 STM32 입문 과정에서 학습한 Timer, ADC, 인터럽트, 통신(I2C/UART)등의 개별 기술을 하나의 시스템으로 통합 구현해보고자 STM32 알람시계 프로젝트를 기획



## 2. 시스템 아키텍쳐
### 1. 시스템 구성도 
![구성도](https://github.com/user-attachments/assets/34aae5f9-291a-4256-8f5b-97dbb59b5186)



### 2. Software FSM

## 3. 기능 설명
### 1. 상태 머신 기반 모드 전환 
사용자 버튼(User Button)을 눌러 4가지 모드를 순환하며 기능을 설정합니다.
1. **Normal Mode (기본 시계):** 현재 시간(AM/PM, 시:분:초)과 알람 설정 여부(AL)를 표시
2. **Time Setting Mode (시간 설정)**
    *  Shield의 상하좌우 버튼을 이용해 AM/PM 및 시, 분, 초를 변경
   * 커서를 이동하여 원하는 단위의 값을 설정 및 음악 선택
3.  **Alarm Setting Mode (알람 설정):**
    * 시간 설정과 동일한 방식으로 알람 시간을 지정
    * 설정이 완료되면 화면에 'AL' 심볼이 표시되며, 해당 시간이 되면 부저가 울림
4.  **Music Select Mode (음악 선택):**
    * 2가지 알람음(오징어 게임, ) 중 하나를 선택
    * 선택된 음악은 알람 작동 시 PWM 신호를 통해 부저로 연주

### 2. ADC 버튼 제어
5개의 버튼을 단일 ADC핀으로 식별하고, 펄스 폭 측정을 통해 입력 형태를 구분
1. short Click: 모드 변경 및 설정값 커서 이동
2. Long Click (3초 이상) : 음악 선택 모드 진입
3. Double Click : 알람 설정 모드로 진입
    *  Shield의 상하좌우 버튼을 이용해 AM/PM 및 시, 분, 초를 변경
   * 커서를 이동하여 원하는 단위의 값을 설정 및 음악 선택

### 3. 멜로디 알람 
- 타이머 인터럽트를 통해 설정된 시간에 정확히 알람을 발생시키고, PWM 주파수 변조를 통해 멜로디 재생

### 4. 메모리 저장
- MCU 내부 Flash 메모리 섹터를 제어
 - 전원이 차단되어도 사용자가 설정한 시간, 알람 시각, 멜로디 정보가 지워지지 않음




## 4. 시연 영상 
### 1. 메모리 저장 


https://github.com/user-attachments/assets/3dde8e02-c800-4f44-91f7-fc54a0f063c4

### 2. 음악 설정


https://github.com/user-attachments/assets/e5076886-8a59-4b08-8cfd-0970edae165d


### 3. 알람시간 설정


https://github.com/user-attachments/assets/d3048da1-bba9-455b-b02c-56d1d6b156bd

### 4-1. 알람1 설정 재생


https://github.com/user-attachments/assets/af78bdbc-3396-4400-a56d-9ab62c826f31

### 4-2. 알람2 설정 재생


https://github.com/user-attachments/assets/dd3c977a-ca0a-406b-93d1-e0d614b6a87f



## 5. 시행착오 및 해결방안


| Issue | Cause | Solution |
| :--- | :--- | :--- |
| **버튼 인식 불량** | 기존 로직에서는 버튼을 떼는 순간 인터럽트 상태를 초기화로 인한 타이밍 문제 | 인터럽트트 버튼이 눌렸을 때만 값을 기록하고 초기화는 메인 함수가 기능을 수행 한 후 변수 값을 초기화하여 처리로 버튼 인식 개선 |
| **Flash 메모리 통합 후 LCD 지연** | Flash 메모리 쓰기/지우기를 while 문에서 반복 호출 사용으로 인한 병목 현상 | 실시간 반복 저장을 제거하고 설정이 완료되어 모드를 변경하는 시점 1회만 호출하도록 로직을 변경으로 해결 |

## 6. 주요 기술

| 구성 요소 | 역할 및 기술 |
| :--- | :--- |
| **STM32F429ZI** | 메인 MCU, 전반적인 시스템 로직 및 상태 머신(State Machine) 구현 |
| **STM32 CubeIDE** |  펌웨어 개발 환경 |
| **Peripherals** | **Timer/PWM** (부저 멜로디 재생), **ADC** (버튼 입력), **RTC** (시간 유지), **I2C** (LCD 제어) |


## 7. 개발후기 
**1. 하드웨어와 소프트웨어의 조화**  
단순히 코드로 버튼 신호를 읽기만 하면 될 줄 알았는데, 실제로는 입력이 씹히거나 튀는 현상이 많았습니다. 이를 해결하기 위해 하드웨어 인터럽트와 소프트웨어 타이머를 결합해 보면서, 불완전한 하드웨어 신호를 소프트웨어적으로 보정(디바운스)해주는 것이 얼마나 중요한지 깨달았습니다. 덕분에 싱글/더블 클릭 같은 복잡한 기능도 안정적으로 구현할 수 있었습니다


**2. 효율적인 자원 관리의 필요성**  
초기에는 기능 구현에 집중하여 Flash 저장을 루프 내에서 처리했고, 이로 인해 LCD가 멈추는 현상을 겪으며 임베디드 환경에서는 CPU 점유 시간 관리가 필수적임을 알게 되었습니다. 이를 해결하기 위해 저장 로직을 이벤트 기반으로 변경하였으며, Flash 저장과 같은 무거운 작업은 MCU 자원을 효율적으로 배분하여 처리해야 한다는 것을 배웠습니다.

**3 문제 해결 능력 강조**  
STM32를 학습하고 처음 진행한 프로젝트였기에 기능 구현만으로도 벅찼지만, 예상치 못한 오류들을 만났을 때 오히려 더 깊이 파고들었습니다. '왜 안 될까?'를 끊임없이 고민하며 문제를 해결하는 과정 자체가 가장 큰 배움이었습니다. 비록 서툰 첫걸음이었지만, 이 과정에서 체득한 집요함과 문제 해결 역량은 앞으로 훌륭한 임베디드 엔지니어로 성장하는 데 가장 단단한 기반이 될 것입니다.





